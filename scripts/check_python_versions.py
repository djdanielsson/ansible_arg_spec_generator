#!/usr/bin/env python3
"""
Authoritative Python version management script.

This script acts as a single source of truth for Python version support. It:
1.  Fetches the list of Python releases from the official
    `actions/python-versions` manifest, avoiding GitHub API rate limits.
2.  Filters for STABLE supported versions (e.g., 3.8 and newer).
3.  Updates the `pyproject.toml` classifiers to perfectly match the
    supported versions, adding new ones and removing old ones.
4.  Provides version lists in various formats for CI/CD automation.

Generated by: Gemini 2.5 Pro
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import List, Set

import requests
from packaging import version

# --- Configuration Constants ---

# The path to your pyproject.toml file, relative to this script's parent directory.
PYPROJECT_PATH: Path = Path(__file__).parent.parent / "pyproject.toml"

# The minimum major.minor Python version to support.
MIN_PYTHON_VERSION: str = "3.8"

# The URL for the version manifest. This avoids GitHub API rate limiting.
VERSIONS_MANIFEST_URL: str = "https://raw.githubusercontent.com/actions/python-versions/main/versions-manifest.json"


# --- Core Functions ---


def get_supported_python_versions() -> List[str]:
    """
    Get supported Python versions from the public manifest.

    Returns:
        A sorted list of "major.minor" version strings (e.g., ["3.8", "3.9"]).
    """
    print("üîç Fetching Python versions manifest...", file=sys.stderr)
    try:
        response = requests.get(VERSIONS_MANIFEST_URL, timeout=30)
        response.raise_for_status()
        releases = response.json()
    except requests.RequestException as e:
        print(f"‚ùå Could not fetch version manifest: {e}", file=sys.stderr)
        sys.exit(1)

    supported_versions: Set[str] = set()
    print(
        f"üìã Found {len(releases)} releases. Filtering for stable versions...",
        file=sys.stderr,
    )

    for release in releases:
        # Only proceed if the release is marked as stable.
        if release.get("stable"):
            full_version_str = release.get("version", "")
            match = re.match(r"(3\.\d+)", full_version_str)
            if match:
                ver = match.group(1)
                if version.parse(ver) >= version.parse(MIN_PYTHON_VERSION):
                    supported_versions.add(ver)

    sorted_versions = sorted(list(supported_versions), key=version.parse)
    print(f"üéØ Supported stable versions: {sorted_versions}", file=sys.stderr)
    return sorted_versions


def get_current_versions() -> Set[str]:
    """
    Get Python versions currently declared in pyproject.toml.

    Returns:
        A set of "major.minor" version strings found in the classifiers.
    """
    if not PYPROJECT_PATH.exists():
        print(f"‚ùå {PYPROJECT_PATH} not found.", file=sys.stderr)
        return set()
    content = PYPROJECT_PATH.read_text()
    return set(re.findall(r'"Programming Language :: Python :: (3\.\d+)"', content))


def update_pyproject_toml(target_versions: List[str]) -> bool:
    """
    Update pyproject.toml to match the target Python versions.

    This function intelligently replaces the entire block of Python classifiers
    with a new, sorted list, while preserving all other classifiers.

    Args:
        target_versions: The complete list of versions that should be present.

    Returns:
        True if the update was successful, False otherwise.
    """
    if not PYPROJECT_PATH.exists():
        print(f"‚ùå {PYPROJECT_PATH} not found.", file=sys.stderr)
        return False

    content = PYPROJECT_PATH.read_text()

    classifier_match = re.search(r"classifiers\s*=\s*\[(.*?)\]", content, re.DOTALL)
    if not classifier_match:
        print(
            "‚ùå Could not find 'classifiers' array in pyproject.toml.", file=sys.stderr
        )
        return False

    full_block = classifier_match.group(0)
    inner_content = classifier_match.group(1)

    # Preserve any classifiers that are not Python version declarations
    other_classifiers = [
        line.strip()
        for line in inner_content.strip().split("\n")
        if "Programming Language :: Python ::" not in line and line.strip()
    ]

    # Generate the new, sorted list of Python version classifiers
    python_classifiers = [
        f'"Programming Language :: Python :: {v}",' for v in target_versions
    ]

    # Combine, sort, and format the new list of all classifiers
    all_new_classifiers = sorted(other_classifiers) + python_classifiers
    new_inner_content = "\n".join(f"    {c}" for c in all_new_classifiers)
    new_block = f"classifiers = [\n{new_inner_content}\n]"

    # Atomically replace the old block with the new one
    new_content = content.replace(full_block, new_block)
    PYPROJECT_PATH.write_text(new_content)
    return True


# --- Main Execution ---


def main() -> int:
    """Main script execution logic."""
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be updated without changing files.",
    )
    parser.add_argument(
        "--check-only",
        action="store_true",
        help="Exit with a non-zero status code if files need updating.",
    )
    parser.add_argument(
        "--format",
        choices=["json", "list", "latest", "ci"],
        help=(
            "Output versions for automation and exit.\n"
            "  - json:   JSON array\n"
            "  - list:   Space-separated list\n"
            "  - latest: The single latest version\n"
            "  - ci:     GitHub Actions output format"
        ),
    )
    args = parser.parse_args()

    supported_versions = get_supported_python_versions()

    # Handle CI/automation output formats first
    if args.format:
        if not supported_versions:
            print("‚ùå No supported Python versions found.", file=sys.stderr)
            return 1
        if args.format == "json":
            print(json.dumps(supported_versions))
        elif args.format == "list":
            print(" ".join(supported_versions))
        elif args.format == "latest":
            print(supported_versions[-1])
        elif args.format == "ci":
            print(f"versions={json.dumps(supported_versions)}")
            print(f"latest={supported_versions[-1]}")
        return 0

    # Proceed with interactive/update logic
    print("\nüêç Python Version Check")
    print("=" * 40)

    current_versions = get_current_versions()
    supported_set = set(supported_versions)

    if current_versions == supported_set:
        print("‚úÖ `pyproject.toml` is up-to-date.")
        return 0

    print("‚ùóÔ∏è `pyproject.toml` needs updating.")
    added = sorted(list(supported_set - current_versions))
    removed = sorted(list(current_versions - supported_set))
    if added:
        print(f"   ‚ûï Versions to add: {added}")
    if removed:
        print(f"   ‚ûñ Versions to remove: {removed}")

    # ‚úÖ FIX: Use underscore instead of hyphen
    if args.check_only:
        print("\n‚ÑπÔ∏è Exiting with status 1 due to --check-only flag.")
        return 1

    # ‚úÖ FIX: Use underscore instead of hyphen
    if args.dry_run:
        print("\nüîç DRY RUN: No files will be changed.")
    else:
        print("\nüöÄ Updating `pyproject.toml`...")
        if update_pyproject_toml(supported_versions):
            print("‚úÖ Successfully updated `pyproject.toml`.")
        else:
            print("‚ùå Update failed.")
            return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
